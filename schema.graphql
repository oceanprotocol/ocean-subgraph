type PoolFactory @entity {
    id: ID!
    totalValueLocked: [TokenValue]                    # total value locked represented in the base token                           
    totalLiquidity: [TokenValue]                      # total liquidity for each base token 
    totalSwapVolume: [TokenValue]                     # total swap volume for each base token
    totalSwapFee: [TokenValue]                        # All the swap fee in Ocean

    poolCount: Int!                                       # Number of pools
    finalizedPoolCount: Int!                              # Number of finalized pools
    orderCount: BigInt                                    # Number of total consumes
    totalOrderVolume: BigDecimal                          # probably remove due to inconsistencies and imposibility to calculate
   
    pools: [Pool!] @derivedFrom(field: "factoryID")
}

type DatatokenFactory @entity {
  id: ID!
  tokenCount: Int!                                        # Number of datatokens
  datatokens: [Tokens!] @derivedFrom(field: "factory")
}

type Global @entity {
    id: ID!

    totalValueLocked: [TokenValuePair]                    # total value locked represented in the base token 
    totalLiquidity: [TokenValuePair]                      # total liquidity for each base token 
    totalSwapVolume: [TokenValuePair]                     # total swap volume for each base token. pools and fre             
    
    totalOrderVolume: BigDecimal
     
    orderCount: BigInt                                    # Number of total consumes, pools + fre

    poolCount: Int!                                       # Number of pools for all factories
    finalizedPoolCount: Int!                              # Number of finalized pools for all factories
}

type TokenValue {

   token : Token!
   value : BigDecimal!

}

type Token @entity {
    id: ID!                                               # 
    symbol: String                                        #
    name: String                                          #
    decimals: Int!                                        #
    address: String!                                      #
    cap: BigDecimal!                                      #
    supply: BigDecimal!                                   #
    isDatatoken: Boolean!                                 #

    factory: DatatokenFactory                             #

    creator: String                                       # TODO:
    publisher: String                                     # TODO:
    minter: String                                        # TODO:
    editor: String                                        # TODO:

    holderCount: BigInt                                   # Number of addresses holding a balance of datatoken
    orderCount: BigInt                                    # Number of orders executed for this datatoken

    createTime: Int                                       # Block time datatoken was created
    tx: Bytes                                             # Datatoken creation transaction id
    block: Int                                            # Block number when it was created
}

type Pool @entity {
    id: ID!                                             # Pool address
    poolFactory: PoolFactory!                           # Pool factory
    controller: Bytes!                                  # Controller address
    isPublicSwap: Boolean!                              # TODO : what is this?
    isFinalized: Boolean!                               # only finalized pools are relevant to us
    
    symbol: String                                      # Pool token symbol
    name: String                                        # Pool token name
    cap: BigInt                                         # Maximum supply if any
    isActive: Boolean!                                  # 
    swapFee: BigDecimal!                                # Swap Fees

    totalWeight: BigDecimal!                            # TODO: What is this?
    totalShares: BigDecimal!                            # Total pool token shares
    totalSwapVolume: BigDecimal!                        # Total swap volume in main token
    totalSwapFee: BigDecimal!                           # TODO: is this correct ? Total swap fee in main token 

    totalValueLocked: BigDecimal!                            # value locked in pool expressed in main token (captures both Ocean and Datatoken)

    spotPrice: BigDecimal!
    consumePrice: BigDecimal!                           # TODO: still need?

    // what is the point of the counts, we never used them => remove
    joinCount: BigInt!                                 # liquidity has been added
    exitCount: BigInt!                                 # liquidity has been removed
    swapCount: BigInt!
    transactionCount: BigInt!                          # Number of transactions in this pool involving liquidity changes
    
    // remove
    datatokenAddress: String!
   
    createTime: Int!                                    # Block time pool was created
    tx: Bytes                                           # Pool creation transaction id
    block

    tokens: [PoolToken!] @derivedFrom(field: "poolId")
    shares: [PoolShare!] @derivedFrom(field: "poolId")
    transactions: [PoolTransaction!] @derivedFrom(field: "pool")
}

type PoolToken @entity {
    id: ID!                                             # poolId + token address
    pool: Pool!                                         # 
    isDatatoken: Boolean!                               # if the token is a datatoken , not sure if this makes sense since it is duplicate information found on token
    token: Token!
    balance: BigDecimal!                                # balance of the token in this pool
    denormWeight: BigDecimal!                       
    symbol: String                                      # should we keep this, it is found on token?
    name: String                                        # should we keep this, it is found on token?
    decimals: Int                                       # should we keep this, it is found on token?
}

type PoolShare @entity {
  id: ID!                                                    # poolId + userAddress
  user: User!
  pool: Pool!
  balance: BigDecimal!
}

type PoolTransaction @entity {
  id: ID!                                                    # pool tx
  pool: Pool                                                 # Pool related to this tx
  user: User                                                 # User that initiates the swap

  sharesTransferAmount: BigDecimal!                          # Number of shares transfered
  sharesBalance: BigDecimal!                                 # TODO: what is this?


  tx: Bytes!
  event: String
  block: Int!
  timestamp: Int!
  gasUsed: BigDecimal!
  gasPrice: BigDecimal!

  tokens: [TokenValue!]                                      # tokens transfered 
}

type Order @entity {                                         # renamed from TokenOrder to Order
  id: ID!                                                    # datatokenId + userAddress + tx
  token: Token!

  consumer: User!
  payer: User!
  amount: BigDecimal!
  serviceId: Int!
  marketFeeCollector: User
  marketFee: BigDecimal!

  timestamp: Int!
  tx: Bytes
  block: Int!
}

type TokenTransaction @entity {
  id: ID! # Log ID
  event: String
  token: Token
  user: User

  block: Int!
  gasUsed: BigDecimal!
  gasPrice: BigDecimal!
  timestamp: Int!
  tx: Bytes!
}

type User @entity {
  id: ID!
  sharesOwned: [PoolShare!] @derivedFrom(field: "user")
  tokenBalancesOwned: [TokenValue!]
  tokensOwned: [Token!] @derivedFrom(field: "minter")
  poolTransactions: [PoolTransaction!] @derivedFrom(field: "user")
  tokenTransactions: [TokenTransaction!] @derivedFrom(field: "user")
  orders: [Order!] @derivedFrom(field: "payer")
  freSwaps: [FixedRateExchangeSwap!] @derivedFrom(field: "by")
}

type FixedRateExchange @entity {
  id: ID!                                                    # fixed rate exchange id
  exchangeOwner: User!
  datatoken: Token!
  baseToken: Token!
  rate: BigDecimal!
  active: Boolean!
  updates: [FixedRateExchangeUpdate!] @derivedFrom(field: "exchangeId")
  swaps: [FixedRateExchangeSwap!] @derivedFrom(field: "exchangeId")
}

type FixedRateExchangeUpdate @entity {
  id: ID!
  exchangeId: FixedRateExchange!
  oldRate: BigDecimal!
  newRate: BigDecimal!
  oldActive: Boolean!
  newActive: Boolean!
  block: Int!
  timestamp: Int!
  tx: Bytes!
}

type FixedRateExchangeSwap @entity {
  id: ID!
  exchangeId: FixedRateExchange!
  by: User!
  baseTokenAmount: BigDecimal!
  dataTokenAmount: BigDecimal!
  block: Int!
  timestamp: Int!
  tx: Bytes!
}

type Dispenser @entity {
  id: ID! # dispenser datatoken
  active: Boolean!
  owner: User!
  minterApproved: Boolean!
  isTrueMinter: Boolean!
  maxTokens: BigDecimal!
  maxBalance: BigDecimal!
  balance: BigDecimal!
  datatoken: Datatoken!
  dispenses: [DispenserTransaction!] @derivedFrom(field: "dispenserId")
}

type DispenserTransaction @entity {
  id: ID!
  dispenserId: Dispenser!
  datatoken: Token!
  user: User!
  amount: BigDecimal!
  block: Int!
  timestamp: Int!
  tx: Bytes!
  type: String!
}


type PoolSnapshotTokenValue @entity {
  id: ID!                                                            # pool tx +  tokenAddress
  token: Token!
  value: BigDecimal!                                            
  tokenReserve: BigDecimal!
  feeValue: BigDecimal!                                              # Swap fee value in OCEAN
  type: String!
  poolSnapshot: PoolSnapshot! 
}


type PoolSnapshot @entity {
  id: ID!
  pool: Pool!
  totalShares: BigDecimal!
  swapVolume: BigDecimal!                                             # swap value 24h
  swapFees: BigDecimal!                                               # swap fee value 24h  
  timestamp: Int!                                                     # date without time
  spotPrice: BigDecimal!                                              # TODO: last spot price or first one?
  tokens: [PoolSnapshotTokenValue!] @derivedFrom(field: "poolSnapshot")
}


// shouldn't we move this to aquarius?
type MetadataUpdate @entity {
  id: ID! # update tx +  datatokenAddress
  datatokenId: Datatoken!

  datatokenAddress: String!
  userAddress: String!



  block: Int!
  timestamp: Int!
  tx: Bytes!
}
